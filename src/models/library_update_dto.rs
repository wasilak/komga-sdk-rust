/*
 * Komga API
 *
 * Komga REST API.  ## Reference  Check the API reference: - on the [Komga website](https://komga.org/docs/openapi/komga-api) - on any running Komga instance at `/swagger-ui.html` - on [GitHub](https://raw.githubusercontent.com/gotson/komga/refs/heads/master/komga/docs/openapi.json)  ## Authentication  Most endpoints require authentication. Authentication is done using either: - Basic Authentication - Passing an API Key in the `X-API-Key` header  ## Sessions  Upon successful authentication, a session is created, and can be reused.  - By default, a `KOMGA-SESSION` cookie is set via `Set-Cookie` response header. This works well for browsers and clients that can handle cookies. - If you specify a header `X-Auth-Token` during authentication, the session ID will be returned via this same header. You can then pass that header again for subsequent requests to reuse the session.  If you need to set the session cookie later on, you can call `/api/v1/login/set-cookie` with `X-Auth-Token`. The response will contain the `Set-Cookie` header.  ## Remember Me  During authentication, if a request parameter `remember-me` is passed and set to `true`, the server will also return a `komga-remember-me` cookie. This cookie will be used to login automatically even if the session has expired.  ## Logout  You can explicitly logout an existing session by calling `/api/logout`. This would return a `204`.  ## Deprecation  API endpoints marked as deprecated will be removed in the next major version.
 *
 * The version of the OpenAPI document: 1.23.4
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// LibraryUpdateDto : Fields to update. You can omit fields you don't want to update.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct LibraryUpdateDto {
    #[serde(rename = "analyzeDimensions", skip_serializing_if = "Option::is_none")]
    pub analyze_dimensions: Option<bool>,
    #[serde(rename = "convertToCbz", skip_serializing_if = "Option::is_none")]
    pub convert_to_cbz: Option<bool>,
    #[serde(rename = "emptyTrashAfterScan", skip_serializing_if = "Option::is_none")]
    pub empty_trash_after_scan: Option<bool>,
    #[serde(rename = "hashFiles", skip_serializing_if = "Option::is_none")]
    pub hash_files: Option<bool>,
    #[serde(rename = "hashKoreader", skip_serializing_if = "Option::is_none")]
    pub hash_koreader: Option<bool>,
    #[serde(rename = "hashPages", skip_serializing_if = "Option::is_none")]
    pub hash_pages: Option<bool>,
    #[serde(rename = "importBarcodeIsbn", skip_serializing_if = "Option::is_none")]
    pub import_barcode_isbn: Option<bool>,
    #[serde(rename = "importComicInfoBook", skip_serializing_if = "Option::is_none")]
    pub import_comic_info_book: Option<bool>,
    #[serde(rename = "importComicInfoCollection", skip_serializing_if = "Option::is_none")]
    pub import_comic_info_collection: Option<bool>,
    #[serde(rename = "importComicInfoReadList", skip_serializing_if = "Option::is_none")]
    pub import_comic_info_read_list: Option<bool>,
    #[serde(rename = "importComicInfoSeries", skip_serializing_if = "Option::is_none")]
    pub import_comic_info_series: Option<bool>,
    #[serde(rename = "importComicInfoSeriesAppendVolume", skip_serializing_if = "Option::is_none")]
    pub import_comic_info_series_append_volume: Option<bool>,
    #[serde(rename = "importEpubBook", skip_serializing_if = "Option::is_none")]
    pub import_epub_book: Option<bool>,
    #[serde(rename = "importEpubSeries", skip_serializing_if = "Option::is_none")]
    pub import_epub_series: Option<bool>,
    #[serde(rename = "importLocalArtwork", skip_serializing_if = "Option::is_none")]
    pub import_local_artwork: Option<bool>,
    #[serde(rename = "importMylarSeries", skip_serializing_if = "Option::is_none")]
    pub import_mylar_series: Option<bool>,
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "oneshotsDirectory", skip_serializing_if = "Option::is_none")]
    pub oneshots_directory: Option<String>,
    #[serde(rename = "repairExtensions", skip_serializing_if = "Option::is_none")]
    pub repair_extensions: Option<bool>,
    #[serde(rename = "root", skip_serializing_if = "Option::is_none")]
    pub root: Option<String>,
    #[serde(rename = "scanCbx", skip_serializing_if = "Option::is_none")]
    pub scan_cbx: Option<bool>,
    #[serde(rename = "scanDirectoryExclusions", skip_serializing_if = "Option::is_none")]
    pub scan_directory_exclusions: Option<Vec<String>>,
    #[serde(rename = "scanEpub", skip_serializing_if = "Option::is_none")]
    pub scan_epub: Option<bool>,
    #[serde(rename = "scanForceModifiedTime", skip_serializing_if = "Option::is_none")]
    pub scan_force_modified_time: Option<bool>,
    #[serde(rename = "scanInterval", skip_serializing_if = "Option::is_none")]
    pub scan_interval: Option<ScanInterval>,
    #[serde(rename = "scanOnStartup", skip_serializing_if = "Option::is_none")]
    pub scan_on_startup: Option<bool>,
    #[serde(rename = "scanPdf", skip_serializing_if = "Option::is_none")]
    pub scan_pdf: Option<bool>,
    #[serde(rename = "seriesCover", skip_serializing_if = "Option::is_none")]
    pub series_cover: Option<SeriesCover>,
}

impl LibraryUpdateDto {
    /// Fields to update. You can omit fields you don't want to update.
    pub fn new() -> LibraryUpdateDto {
        LibraryUpdateDto {
            analyze_dimensions: None,
            convert_to_cbz: None,
            empty_trash_after_scan: None,
            hash_files: None,
            hash_koreader: None,
            hash_pages: None,
            import_barcode_isbn: None,
            import_comic_info_book: None,
            import_comic_info_collection: None,
            import_comic_info_read_list: None,
            import_comic_info_series: None,
            import_comic_info_series_append_volume: None,
            import_epub_book: None,
            import_epub_series: None,
            import_local_artwork: None,
            import_mylar_series: None,
            name: None,
            oneshots_directory: None,
            repair_extensions: None,
            root: None,
            scan_cbx: None,
            scan_directory_exclusions: None,
            scan_epub: None,
            scan_force_modified_time: None,
            scan_interval: None,
            scan_on_startup: None,
            scan_pdf: None,
            series_cover: None,
        }
    }
}
/// 
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ScanInterval {
    #[serde(rename = "DISABLED")]
    Disabled,
    #[serde(rename = "HOURLY")]
    Hourly,
    #[serde(rename = "EVERY_6H")]
    Every6H,
    #[serde(rename = "EVERY_12H")]
    Every12H,
    #[serde(rename = "DAILY")]
    Daily,
    #[serde(rename = "WEEKLY")]
    Weekly,
}

impl Default for ScanInterval {
    fn default() -> ScanInterval {
        Self::Disabled
    }
}
/// 
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SeriesCover {
    #[serde(rename = "FIRST")]
    First,
    #[serde(rename = "FIRST_UNREAD_OR_FIRST")]
    FirstUnreadOrFirst,
    #[serde(rename = "FIRST_UNREAD_OR_LAST")]
    FirstUnreadOrLast,
    #[serde(rename = "LAST")]
    Last,
}

impl Default for SeriesCover {
    fn default() -> SeriesCover {
        Self::First
    }
}

