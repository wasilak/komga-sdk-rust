/*
 * Komga API
 *
 * Komga REST API.  ## Reference  Check the API reference: - on the [Komga website](https://komga.org/docs/openapi/komga-api) - on any running Komga instance at `/swagger-ui.html` - on [GitHub](https://raw.githubusercontent.com/gotson/komga/refs/heads/master/komga/docs/openapi.json)  ## Authentication  Most endpoints require authentication. Authentication is done using either: - Basic Authentication - Passing an API Key in the `X-API-Key` header  ## Sessions  Upon successful authentication, a session is created, and can be reused.  - By default, a `KOMGA-SESSION` cookie is set via `Set-Cookie` response header. This works well for browsers and clients that can handle cookies. - If you specify a header `X-Auth-Token` during authentication, the session ID will be returned via this same header. You can then pass that header again for subsequent requests to reuse the session.  If you need to set the session cookie later on, you can call `/api/v1/login/set-cookie` with `X-Auth-Token`. The response will contain the `Set-Cookie` header.  ## Remember Me  During authentication, if a request parameter `remember-me` is passed and set to `true`, the server will also return a `komga-remember-me` cookie. This cookie will be used to login automatically even if the session has expired.  ## Logout  You can explicitly logout an existing session by calling `/api/logout`. This would return a `204`.  ## Deprecation  API endpoints marked as deprecated will be removed in the next major version.
 *
 * The version of the OpenAPI document: 1.23.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`book_analyze`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BookAnalyzeError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`book_refresh_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BookRefreshMetadataError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_book_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBookFileError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_book_read_progress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBookReadProgressError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_book_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadBookFileError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_book_file1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadBookFile1Error {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_books_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllBooksDeprecatedError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_book_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBookByIdError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_book_sibling_next`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBookSiblingNextError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_book_sibling_previous`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBookSiblingPreviousError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_books`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBooksError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_books_duplicates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBooksDuplicatesError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_books_latest`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBooksLatestError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_books_on_deck`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBooksOnDeckError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_read_lists_by_book_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetReadListsByBookIdError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mark_book_read_progress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarkBookReadProgressError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_book_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateBookMetadataError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_book_metadata_by_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateBookMetadataByBatchError {
    Status400(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Required role: **ADMIN**
pub async fn book_analyze(configuration: &configuration::Configuration, book_id: &str) -> Result<(), Error<BookAnalyzeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}/analyze", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<BookAnalyzeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Required role: **ADMIN**
pub async fn book_refresh_metadata(configuration: &configuration::Configuration, book_id: &str) -> Result<(), Error<BookRefreshMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}/metadata/refresh", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<BookRefreshMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Required role: **ADMIN**
pub async fn delete_book_file(configuration: &configuration::Configuration, book_id: &str) -> Result<(), Error<DeleteBookFileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}/file", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteBookFileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Mark book as unread
pub async fn delete_book_read_progress(configuration: &configuration::Configuration, book_id: &str) -> Result<(), Error<DeleteBookReadProgressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}/read-progress", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteBookReadProgressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download the book file.  Required role: **FILE_DOWNLOAD**
pub async fn download_book_file(configuration: &configuration::Configuration, book_id: &str) -> Result<serde_json::Value, Error<DownloadBookFileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}/file", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DownloadBookFileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download the book file.  Required role: **FILE_DOWNLOAD**
pub async fn download_book_file1(configuration: &configuration::Configuration, book_id: &str) -> Result<serde_json::Value, Error<DownloadBookFile1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}/file/*", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DownloadBookFile1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use POST /api/v1/books/list instead. Deprecated since 1.19.0.
pub async fn get_all_books_deprecated(configuration: &configuration::Configuration, search: Option<&str>, library_id: Option<Vec<String>>, media_status: Option<Vec<String>>, read_status: Option<Vec<String>>, released_after: Option<String>, tag: Option<Vec<String>>, unpaged: Option<bool>, page: Option<i32>, size: Option<i32>, sort: Option<Vec<String>>) -> Result<models::PageBookDto, Error<GetAllBooksDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_search = search;
    let p_query_library_id = library_id;
    let p_query_media_status = media_status;
    let p_query_read_status = read_status;
    let p_query_released_after = released_after;
    let p_query_tag = tag;
    let p_query_unpaged = unpaged;
    let p_query_page = page;
    let p_query_size = size;
    let p_query_sort = sort;

    let uri_str = format!("{}/api/v1/books", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_library_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("library_id".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("library_id", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_media_status {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("media_status".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("media_status", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_read_status {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("read_status".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("read_status", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_released_after {
        req_builder = req_builder.query(&[("released_after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("tag".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("tag", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_unpaged {
        req_builder = req_builder.query(&[("unpaged", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("sort".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("sort", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PageBookDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PageBookDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllBooksDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_book_by_id(configuration: &configuration::Configuration, book_id: &str) -> Result<models::BookDto, Error<GetBookByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BookDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BookDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBookByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_book_sibling_next(configuration: &configuration::Configuration, book_id: &str) -> Result<models::BookDto, Error<GetBookSiblingNextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}/next", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BookDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BookDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBookSiblingNextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_book_sibling_previous(configuration: &configuration::Configuration, book_id: &str) -> Result<models::BookDto, Error<GetBookSiblingPreviousError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}/previous", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BookDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BookDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBookSiblingPreviousError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_books(configuration: &configuration::Configuration, book_search: models::BookSearch, unpaged: Option<bool>, page: Option<i32>, size: Option<i32>, sort: Option<Vec<String>>) -> Result<models::PageBookDto, Error<GetBooksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_book_search = book_search;
    let p_query_unpaged = unpaged;
    let p_query_page = page;
    let p_query_size = size;
    let p_query_sort = sort;

    let uri_str = format!("{}/api/v1/books/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_unpaged {
        req_builder = req_builder.query(&[("unpaged", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("sort".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("sort", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body_book_search);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PageBookDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PageBookDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBooksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return books that have the same file hash.  Required role: **ADMIN**
pub async fn get_books_duplicates(configuration: &configuration::Configuration, unpaged: Option<bool>, page: Option<i32>, size: Option<i32>, sort: Option<Vec<String>>) -> Result<models::PageBookDto, Error<GetBooksDuplicatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_unpaged = unpaged;
    let p_query_page = page;
    let p_query_size = size;
    let p_query_sort = sort;

    let uri_str = format!("{}/api/v1/books/duplicates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_unpaged {
        req_builder = req_builder.query(&[("unpaged", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("sort".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("sort", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PageBookDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PageBookDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBooksDuplicatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return newly added or updated books.
pub async fn get_books_latest(configuration: &configuration::Configuration, unpaged: Option<bool>, page: Option<i32>, size: Option<i32>) -> Result<models::PageBookDto, Error<GetBooksLatestError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_unpaged = unpaged;
    let p_query_page = page;
    let p_query_size = size;

    let uri_str = format!("{}/api/v1/books/latest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_unpaged {
        req_builder = req_builder.query(&[("unpaged", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PageBookDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PageBookDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBooksLatestError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return first unread book of series with at least one book read and no books in progress.
pub async fn get_books_on_deck(configuration: &configuration::Configuration, library_id: Option<Vec<String>>, page: Option<i32>, size: Option<i32>) -> Result<models::PageBookDto, Error<GetBooksOnDeckError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_library_id = library_id;
    let p_query_page = page;
    let p_query_size = size;

    let uri_str = format!("{}/api/v1/books/ondeck", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_library_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("library_id".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("library_id", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PageBookDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PageBookDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBooksOnDeckError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_read_lists_by_book_id(configuration: &configuration::Configuration, book_id: &str) -> Result<Vec<models::ReadListDto>, Error<GetReadListsByBookIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;

    let uri_str = format!("{}/api/v1/books/{bookId}/readlists", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ReadListDto&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ReadListDto&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetReadListsByBookIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Mark book as read and/or change page progress.
pub async fn mark_book_read_progress(configuration: &configuration::Configuration, book_id: &str, read_progress_update_dto: models::ReadProgressUpdateDto) -> Result<(), Error<MarkBookReadProgressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;
    let p_body_read_progress_update_dto = read_progress_update_dto;

    let uri_str = format!("{}/api/v1/books/{bookId}/read-progress", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body_read_progress_update_dto);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MarkBookReadProgressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set a field to null to unset the metadata. You can omit fields you don't want to update.  Required role: **ADMIN**
pub async fn update_book_metadata(configuration: &configuration::Configuration, book_id: &str, book_metadata_update_dto: models::BookMetadataUpdateDto) -> Result<(), Error<UpdateBookMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_book_id = book_id;
    let p_body_book_metadata_update_dto = book_metadata_update_dto;

    let uri_str = format!("{}/api/v1/books/{bookId}/metadata", configuration.base_path, bookId=crate::apis::urlencode(p_path_book_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body_book_metadata_update_dto);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateBookMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set a field to null to unset the metadata. You can omit fields you don't want to update.  Required role: **ADMIN**
pub async fn update_book_metadata_by_batch(configuration: &configuration::Configuration, request_body: std::collections::HashMap<String, models::BookMetadataUpdateDto>) -> Result<(), Error<UpdateBookMetadataByBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_request_body = request_body;

    let uri_str = format!("{}/api/v1/books/metadata", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateBookMetadataByBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

